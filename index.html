<html>
<head><title>CSCI 330 Spring 2020: project</title></head>
<body>
<body>
<h3>CSCI 330 Course project</h3>

<p><table border="1"><tr><td><b>Note:</b> there are likely to be gaps/ambiguities/conflicts
in the initial language specification given below.  If you find such an issue, or need
clarification on the language specifications, please contact the instructor as soon as
possible.</td></tr></table><p>
<p>
The course project this semester is to create, using lex and yacc, a syntax
checker for a small programming language, <em>fooish</em>. Details
are given below.
<p>
The project is worth a total of 15% of your grade, and is due at 5p.m. on Friday April 10th.
<p>
<p>
<em><b>Submissions up to 24 hours late will be penalized 10%, submissions 24-48 hours late will
be penalized 25%, submissions 48-72 hours late will be penalized 40%. No submissions will be accepted more than 72 hours late.</b></em>
<p>
The project will be distributed and submitted using our
standard <a href="../../../guides/gitstudent.html">
git approach</a>, i.e. obtained using
<ul>
<code> ssh -x csci fork csci330/project csci330/$USER/project </code>
<br><code> git clone csci:csci330/$USER/project </code>
<br>and submitted using
<br><code> git push origin master</code>
</ul>
<p>
The initial repository contents include:
<ul>
   <li> a README file
   <li> starting versions of fooChecker.lex and fooChecker.yacc
   <li> a makefile, allowing you to build fooChecker from fooChecker.lex and fooChecker.yacc
   <li> a sample input file, valid/t0, that passes the initial fooChecker
   <li> a sample input file, invalid/e0, that fails the initial fooChecker
</ul>
<table border="1"><tr><td><b>Notes on code quality </b><p>
While there are not official code standards for the course, this is an upper level course
and as such it is expected that all code submissions will be of high quality -
i.e. the code compiles without
errors or warnings, does not crash when run, uses sensible and informative prompts
and error messages, is well laid out, uses sensible identifiers,
has reasonable commenting for complex steps, etc.  Marks will be deducted for poor
quality code even if the functional behaviour is correct.
</td></tr></table>
<p>
<h4>Project requirements and marking scheme</h4>
The objective is to create, using lex and yacc, an executable named <code>fooChecker</code>
that can be applied to <code>fooish</code> source code to determine if the source code
is a valid <code>fooish</code> program.  (A description of the <code>fooish</code> language
is given further below.)
<p>
To do so, you will need to create files <code>foo.lex</code>, <code>foo.yacc</code>,
and a <code>makefile</code> that will properly build the <code>fooChecker</code>
executable.
<p>
The <code>fooChecker</code> should provide a clear message if the code is valid,
and appropriate error messages if the code is not valid, e.g.
<table border="1"><tr><td><pre>
./fooChecker < someProg.foo

Checking complete, code is valid.
</pre></td></tr></table>
<p>
Note: as you will find, generating "appropriate error messages" is pretty tricky - you'll
soon see why some of the error messages generated by compilers are so cryptic.
Generating any error message (when there is an error of course) is a good start.
<p>
Some examples of lex files, yacc files, and makefiles are provided for
various simple languages through the course
<a href="../code/yacc/index.html">lex/yacc examples</a> page.
<p>
The marking will be handled as follows:
<ul>
   <p><li> There are a certain number of marks assigned to each language feature,
        totalling 88 marks in all.
   <p><li> The project will be recorded out of 75 marks, i.e. you do not need to
        complete every feature to get 100% on the project.  If you do get more
        than 75/75 then the excess will be recorded as a bonus mark for the course.
   <p><li> For each feature, 75% of the mark will be based on simply getting the
        structural syntax checking working, i.e. does it follow the basic CFG
        structure required.
        <p>The remaining 25% is based on the augmented grammar checking,
        e.g. do types match, have variables been declared before being used,
        correct handling of scope, etc.
        <p>Note that you have quite a bit of flexibility in terms
        of which features you choose to implement, and whether you aim for full checking
        or just the CFG checking for each.
        </td></tr></table>
   <p> The marks breakdown by feature is as follows:
        <br> <b>16 marks: function handling</b>
        <br> &nbsp; - including syntax, function definitions and calls, local variables/scope,
                      proper handling of parameters and return values, etc
        <br> <b>10 marks: selection and iteration</b>
        <br> &nbsp; - including syntax, while loops, the use of if, else-if, else,
                      the boolean test expressions, local block scope, etc
        <br> <b>10 marks: boolean expressions</b>
        <br> &nbsp; - including syntax, literals T and F, the comparison
             operators, compound operators (AND OR NOT), typechecking, etc
        <br> <b>10 marks: arithmetic expressions</b>
        <br> &nbsp; - including syntax, literals for reals and integers,
              comparison operators, the unary negation operator, the listed math operators
              (+ - * / ^ MOD), correct precedence and associativity, typechecking, etc
        <br> <b>10 marks: string expressions</b>
        <br> &nbsp; - including syntax, literals, escape sequences for " and \,
                comparison operators,
                concatenation and substring operators, typechecking, etc
        <br> <b>8 marks: I/O</b>
        <br> &nbsp; - including syntax, calls (typechecked) to reads, readi, readr, print
        <br> <b>8 marks: variables</b>
        <br> &nbsp; - including syntax, declaration of variables, checking variables
               are declared before use, etc
        <br> <b>8 marks: assignment statements</b>
        <br> &nbsp; - including syntax, type checking, etc
        <br> <b>8 marks: comments</b>
        <br> &nbsp; - including syntax, proper "stripping" of comments, etc
   <p><li> The assessment of your fooChecker functionality will be based partly on
        test cases developed by the instructor and partly on test cases provided by you.
        <p>
        As such, your project repository must contain two subdirectories, named <code>valid</code>
        and <code>invalid</code>.  These will be used to hold the test cases you have developed,
        and a summary of what they demonstrate.
        <p>
        The README in the top level of your repository should contain a careful summary of
        what you did/did not get working in your fooChecker.
        <p>
        Each file (other than the README) in the <code>valid</code> subdirectory should
        represent a valid (error free) fooish script that your fooChecker correctly
        identifies as valid.
        <p>
        Each file (other than the README) in the <code>invalid</code> subdirectory should represent a "buggy" fooish
        script for which your fooChecker correctly identifies the problem.
        <p>
        The README in each subdirectory should contain a list of what, specifically,
        each file is meant to demonstrate, for example:
<pre>
# from the README in valid:
File f1.foo contains a set of function definitions and calls
  - a function with no parameters
  - a function with 1 parameter
  - a function with two parameters
  - a function call passing a literal value
  - a function call passing a variable
  - a function call passing an expression
... etc ...

# from the README in invalid:
File f1.foo contains a set of function definitions and calls
File e1.foo contains two global variables with the same name (caught by fooChecker)
File e2.foo contains an instance of trying to use mismatched types with a + operator
             ( 27  + "foo" )
... etc ...
</pre>
</ul>

<h4>Fooish language specifications</h4>
Fooish is a dynamically-typed, lexically-scoped scripting language in which functions
and variables must be declared before they are used.
<p>
It requires tokens to be whitespace delimited, but any amount/type of whitespace
is acceptable (e.g. the whitespace between two tokens might be a single space,
a tab, a newline, multiple spaces, combinations, etc).
<p>
Identifiers (function names, variable names, parameter names) consist of
alphabetic characters or underscores, are case-sensitive, and cannot match
any of the language keywords (e.g. VAR while FUNC return etc).
<p>
Assignment statements, variable declarations, function calls, and return
statements are terminated with a semi-colon.
<p>
The data types supported are (fixed-point) real numbers, integers, strings, and booleans - each
of which is discussed below.
<p>
The language uses bash-style comments, i.e. everything from a # to the end of the line.
<p>
<b>Features and syntax examples:</b>
<P> (Note that the specific choice of whitespace used in the examples below is
simply for the sake of readability.)
<ul>
<p><li> <b>Function definitions and calls</b>
   <br> The function definition syntax uses the FUNC keyword (case-senstive),
   specifies a parameter list, and a function body.
   <p>  The function body
   consists of one or more statements (variable declarations, assignment statements,
   function calls), followed by a single return statement.  (To clarify: the final
   statement of the function body must be the return statement.  The return cannot
   be embedded within a loop or if/else block,
   and a function cannot have multiple return statements.)
   <pre>
# EXAMPLE
FUNC product ( x y ) {
  # computes and returns x * y
  VAR result ;
  result = x * y ;
  return result ;
}
</pre>
   Function calls can either be stand-alone (ignoring the return value)
   or part of an expression or assignment statement, e.g.
   <br><code>x = product ( 3 5 ) ;</code>
   <br><code>a = 5 + sqrt ( 3 * f ( 2 ) ) ;</code>
   <br> Note that the passed parameters are simply whitespace delimited,
   and that a function must be declared before it can be called.

<p><li> <b>Variable definitions and use</b>
   <br> Variables can either be global in scope, local to a function, or
   local to a block.  They must be declared before use,
   using the <code>VAR</code> keyword with syntax as follows:
   <br><code> VAR varname ; </code>
   <br>(There is no support for initialization at the point of declaration,
   and no support for declaring multiple variables with a single VAR statement.)
   <br> You cannot have two different variables with the same name and the same
   scope (e.g. you could have a global variable named X and a local variable named X,
   but you could not have two global variables that were both named X).

<p><li> <b>Selection</b>
   <br> The if statement has optional else-if and else components,
   curly brackets are mandatory, and the blocks must consist of one or
   more statements (variable declarations, assignment statements, function calls).
   Blocks must consist of one or more statements (variable declarations, assignment
   statements, function calls).
<pre>
   # note that expr1 and expr2 could be any valid boolean expressions
   if ( expr1 ) {
      # statements
   } else-if ( expr2 ) {
      # statements
   } else {
      # statements
   }
</pre>

<p><Li> <b>Iteration</b>
   <br> The only loop supported is the while loop.  The syntax is shown below,
   the curly-brackets are mandatory, and the blocks must consist of one ore more
   statements (variable declarations, assignment statements, function calls).
<pre>
     # note that expr could be any valid boolean expression
     while ( expr ) {
        # statements
     }
</pre>

<p><li> <b>Operator precedence and associativity</b>
   <br> The standard C precedence and associativity rules are followed for the
        different types of operation
        (though, as detailed below, fooish only supports a subset of the operation types,
         and uses different symbols for some of the operations).
        The use of brackets ( ) is supported normally.

<p><li> <b>Data types </b>
   <br> The supported data types are string, boolean, integer, and real.
   <br> Literals for real numbers are given in fixed point notation, with digits mandatory
        on both sides of the decimal point, and with an optional leading - sign,
        e.g. <code> -1.23 </code>
   <br> Literals for integers consist of one or more digits, with an optional leading - sign,
        e.g. <code> -123</code>
   <br> String literals begin and end with a double quote <code> " </code>, enclosing
        zero or more other characters.
   <br>  To embed a double-quote within the string use
        \" and to embed a \ within the string use \\
   <br> Literals for booleans are T and F (case sensitive).

<p><li> <b> Input/Output operations</b>
   <br> Three input operations are supported: reads, readi, readr
        <br> &nbsp; <code>reads</code> gets a string from standard input and returns it, e.g.
        <br> &nbsp; <code>VAR S ; </code>
        <br> &nbsp; <code>S = reads ( ) ; </code>
        <br> &nbsp; <code>readi( ) </code> gets an integer from standard input and returns it
        <br> &nbsp; <code>readr( ) </code> gets a real number from standard input and returns it
   <p> A single output operation is supported, to display the current value of a variable
        or literal, e.g.:
        <br> &nbsp; <code>print( x ) </code>
        <br> &nbsp; <code>print( "Hello there!" ) </code>

<p><li> <b>String operations</b>
   <br> The supported string operations are as follows:
        <br> &nbsp; - assignment, e.g. <code> str1 := str2 ; </code>
        <br> &nbsp; - equals, e.g. <code> if ( str1 == str2 ) {</code> 
        <br> &nbsp; - not-equals, e.g. <code> if ( str1 &lt;> str2 ) {</code>
        <br> &nbsp; - less than, (ascii-based, char-by-char) e.g. <code>if ( str1 < str2 ) { </code>
        <br> &nbsp; - concatenation, e.g. <code> str0 = str1 + str2 ;</code>
        <br> &nbsp; - substring, (the substring from positions i through j, 0-based, inclusive)
            e.g. <code> str1 = str2 [ i j ] ;</code>

<p><li> <b>Arithmetic operations</b>
   <br> For binary operations, if both operands are integer then the result is integer,
        if one or both operands are real then the result is real.
   <br> The supported unary operator is negation, e.g. <code> y = - x ;</code>
   <br> The only supported binary comparison operators for numbers are
        less than <code> < </code>, <code> equals </code> == </code>,
        and not-equals <code> &lt;> </code>
   <br> The supported binary math operations are <code>+ - / *</code>,
        with <code> ^ </code> used for power,
        and <code> MOD </code> used for modulo (case-sensitive).

<p><li> <b>Boolean operations</b>
   <br> The basic supported operators are assignment <code>:=</code>,
        equals <code>==</code>, not-equals <code> &lt;></code>,
        along with the compound operators <code>AND</code>, <code>OR</code> and
        <code>NOT</code> (also case-sensitive).
   <br> The use of parentheses is supported for compound operators, e.g.
        <br><code>  if ( NOT ( x AND ( y OR z ) ) ) { </code>

<p><li> <b>Assignment statements</b>
   <br> The assignment syntax is
   <br><code> var := expr ; </code>
   <br> where <code>var</code> is a variable that has previously been declared
        and is accessible in the current scope, and <code>expr</code> is a valid expression
        (of any data type).

</ul>

<hr><h4>Sample script</h4>
<pre>
# sumVals ( N )
# -------------
# gets the user to enter N numeric values,
#    computes and returns the sum of them
FUNC sumVals ( N )
{
   VAR sum ;
   sum = 0.0 ;
   VAR i ;
   i = 0 ;
   while ( i < N ) {
      print ( "Enter a number" ) ;
      VAR num ;
      num = readr ( ) ;
      sum = sum + num ;
   }
   return sum ;
}

# try calling our function and displaying the results

VAR numvals ;  # used to decide how many numbers to read
numvals = 10 ;

VAR result ;   # used to store the final sum

   # let's try the function call
result = sumVals ( numvals ) ;

print ( "The sum of your " ) ;
print ( numvals ) ;
print ( " values was " ) ;
print ( result ) ;
</pre>
</body>
</html>
